---
import BaseLayout from "@/layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

const docs = await getCollection("docs");

const dirs: Record<string, Record<string, string>> = {};
const rootFiles: Record<string, string> = {};

const dirNames = new Set<string>();
for (const entry of docs) {
  const parts = entry.id.split("/");
  if (parts.length > 1) dirNames.add(parts[0]);
}

for (const entry of docs) {
  const id = entry.id;
  const { title, description } = entry.data;
  const parts = id.split("/");

  if (parts.length > 1) {
    const dir = parts[0];
    const slug = parts.slice(1).join("/");
    if (slug === "index") continue;
    if (!dirs[dir]) dirs[dir] = {};
    const lines = [title, "---"];
    if (description) lines.push(description);
    lines.push("", `  open /${dir}/${slug}/`);
    dirs[dir][`${slug}.md`] = lines.join("\n");
  } else if (parts[0] !== "index" && !dirNames.has(parts[0])) {
    const slug = parts[0];
    const lines = [title, "---"];
    if (description) lines.push(description);
    lines.push("", `  open /${slug}/`);
    rootFiles[`${slug}.md`] = lines.join("\n");
  }
}

const dynamicFs = JSON.stringify({ dirs, rootFiles });
---

<BaseLayout title="Kevin Jin">
  <script type="application/json" id="fs-data" set:html={dynamicFs} />
  <div id="terminal" tabindex="0">
    <div id="output"></div>
    <div id="input-line">
      <span id="prompt"></span>
      <input id="input" type="text" spellcheck="false" autocomplete="off" autocapitalize="off" />
    </div>
  </div>
</BaseLayout>

<style is:global>
  #terminal {
    position: fixed;
    inset: 0;
    background: #1e1e2e;
    color: #cdd6f4;
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
    line-height: 1.5;
    padding: 16px;
    overflow-y: auto;
    cursor: text;
  }

  #output div {
    white-space: pre-wrap;
    word-break: break-word;
  }

  #input-line {
    display: flex;
    align-items: center;
  }

  #prompt {
    white-space: pre;
    flex-shrink: 0;
  }

  #input {
    flex: 1;
    background: none;
    border: none;
    outline: none;
    color: #cdd6f4;
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
    line-height: 1.5;
    padding: 0;
    margin: 0;
    caret-color: #cdd6f4;
    caret-shape: block;
  }

  .prompt-user { color: #a6e3a1; }
  .prompt-sep { color: #cdd6f4; }
  .prompt-path { color: #89b4fa; }
  .prompt-dollar { color: #cdd6f4; }
  .dir-entry { color: #89b4fa; }
  .accent { color: #b4befe; }
  .label { color: #b4befe; }
  .link { color: #89b4fa; text-decoration: underline; cursor: pointer; }
</style>

<script>
  const dynamicFs = JSON.parse(document.getElementById("fs-data")!.textContent!);

  const filesystem: Record<string, any> = {
    ...dynamicFs.dirs,
    ...dynamicFs.rootFiles,
  };

  let cwd = "~";
  const history: string[] = [];
  let historyIndex = -1;

  const outputEl = document.getElementById("output")!;
  const inputEl = document.getElementById("input") as HTMLInputElement;
  const promptEl = document.getElementById("prompt")!;
  const terminalEl = document.getElementById("terminal")!;

  function renderPrompt(): string {
    const path = cwd;
    return `<span class="prompt-user">kevin@kevinjin.dev</span><span class="prompt-sep">:</span><span class="prompt-path">${path}</span><span class="prompt-dollar"> $ </span>`;
  }

  function updatePrompt() {
    promptEl.innerHTML = renderPrompt();
  }

  function resolvePath(path: string): string[] {
    let parts: string[];
    if (path === "~" || path === "") {
      return [];
    }
    if (path.startsWith("~/")) {
      parts = path.slice(2).split("/").filter(Boolean);
    } else if (path.startsWith("/")) {
      parts = path.slice(1).split("/").filter(Boolean);
    } else {
      const cwdParts = cwd === "~" ? [] : cwd.slice(2).split("/").filter(Boolean);
      parts = [...cwdParts, ...path.split("/").filter(Boolean)];
    }

    const resolved: string[] = [];
    for (const p of parts) {
      if (p === "..") {
        resolved.pop();
      } else if (p !== ".") {
        resolved.push(p);
      }
    }
    return resolved;
  }

  function getNode(parts: string[]): any {
    let node: any = filesystem;
    for (const p of parts) {
      if (node == null || typeof node === "string") return undefined;
      node = node[p];
    }
    return node;
  }

  function pathString(parts: string[]): string {
    return parts.length === 0 ? "~" : "~/" + parts.join("/");
  }

  function appendOutput(html: string) {
    const div = document.createElement("div");
    div.innerHTML = html;
    outputEl.appendChild(div);
  }

  function escapeHtml(s: string): string {
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }

  function neofetchOutput(): string {
    const art = [
      " _  __          _             _ _       ",
      "| |/ /_____   _(_)_ __       | (_)_ __  ",
      "| ' // _ \\ \\ / / | '_ \\   _  | | | '_ \\ ",
      "| . \\  __/\\ V /| | | | | | |_| | | | | |",
      "|_|\\_\\___| \\_/ |_|_| |_|  \\___/|_|_| |_|",
    ];

    const info = [
      ["kevin@kevinjin.dev", ""],
      ["------------------", ""],
      ["Major", "Computer Engineering"],
      ["School", "University of Michigan"],
      ["Email", "kevinjin0420@gmail.com"],
      ["OS", "Kubuntu 22.04 LTS x86_64"],
      ["Host", "ThinkPad P1 Gen 7"],
      ["Kernel", "Linux 6.8.0-94-generic"],
      ["Shell", "zsh 5.8.1"],
      ["DE", "KDE Plasma 6.2.0"],
      ["CPU", "Intel Core Ultra 7 165H @ 5.00 GHz"],
      ["GPU", "NVIDIA RTX 4060 Max-Q"],
    ];

    const lines: string[] = [];
    const maxArt = Math.max(art.length, info.length);
    const artWidth = 44;

    for (let i = 0; i < maxArt; i++) {
      const artLine = i < art.length ? art[i] : " ".repeat(artWidth);
      const padded = artLine.padEnd(artWidth);
      let infoStr = "";
      if (i < info.length) {
        const [label, value] = info[i];
        if (value === "") {
          infoStr = `<span class="accent">${escapeHtml(label)}</span>`;
        } else {
          infoStr = `<span class="label">${escapeHtml(label)}</span>: ${escapeHtml(value)}`;
        }
      }
      lines.push(`<span class="accent">${escapeHtml(padded)}</span>${infoStr}`);
    }

    lines.push("");
    lines.push("Type 'help' for available commands.");
    return lines.join("\n");
  }

  function processCommand(input: string) {
    const trimmed = input.trim();
    if (!trimmed) return;

    const parts = trimmed.split(/\s+/);
    const cmd = parts[0];
    const args = parts.slice(1);

    switch (cmd) {
      case "help": {
        appendOutput([
          "Available commands:",
          "",
          "  help           Show this help message",
          "  ls [dir]       List directory contents",
          "  cd &lt;dir&gt;       Change directory",
          "  cat &lt;file&gt;     Print file contents",
          "  open &lt;target&gt;  Navigate to a URL or page",
          "  pwd            Print working directory",
          "  clear          Clear terminal output",
          "  whoami         Print current user",
          "  neofetch       Display system info",
        ].join("\n"));
        break;
      }

      case "ls": {
        const target = args[0] || "";
        const resolved = target ? resolvePath(target) : resolvePath(cwd);
        const node = getNode(resolved);
        if (node == null || typeof node === "string") {
          appendOutput(`ls: cannot access '${escapeHtml(args[0] || "")}': No such directory`);
          break;
        }
        const entries = Object.keys(node).sort();
        const formatted = entries.map((e) => {
          const isDir = typeof node[e] === "object";
          return isDir
            ? `<span class="dir-entry">${escapeHtml(e)}/</span>`
            : escapeHtml(e);
        });
        appendOutput(formatted.join("  "));
        break;
      }

      case "cd": {
        if (args.length === 0) {
          cwd = "~";
          updatePrompt();
          break;
        }
        const target = args[0];
        const resolved = resolvePath(target);
        const node = getNode(resolved);
        if (node == null || typeof node === "string") {
          appendOutput(`cd: no such directory: ${escapeHtml(target)}`);
          break;
        }
        cwd = pathString(resolved);
        updatePrompt();
        break;
      }

      case "cat": {
        if (args.length === 0) {
          appendOutput("cat: missing operand");
          break;
        }
        const resolved = resolvePath(args[0]);
        const node = getNode(resolved);
        if (node == null) {
          appendOutput(`cat: ${escapeHtml(args[0])}: No such file or directory`);
        } else if (typeof node === "object") {
          appendOutput(`cat: ${escapeHtml(args[0])}: Is a directory`);
        } else {
          appendOutput(escapeHtml(node));
        }
        break;
      }

      case "open": {
        if (args.length === 0) {
          appendOutput("open: missing operand");
          break;
        }
        const target = args[0];
        if (target === "resume.pdf") {
          window.location.href = "/Shengran_Jin_resume.pdf";
        } else if (target.startsWith("http://") || target.startsWith("https://")) {
          window.open(target, "_blank");
        } else if (target.startsWith("/")) {
          window.location.href = target;
        } else {
          const resolved = resolvePath(target);
          const node = getNode(resolved);
          if (typeof node === "string") {
            const urlMatch = node.match(/open ((?:\/|https?:\/\/)\S+)/);
            if (urlMatch) {
              const url = urlMatch[1];
              if (url.startsWith("http")) {
                window.open(url, "_blank");
              } else {
                window.location.href = url;
              }
            } else {
              appendOutput(`open: ${escapeHtml(target)}: no link found in file`);
            }
          } else {
            appendOutput(`open: ${escapeHtml(target)}: unknown target`);
          }
        }
        break;
      }

      case "pwd": {
        const display = cwd === "~" ? "/home/kevin" : "/home/kevin/" + cwd.slice(2);
        appendOutput(escapeHtml(display));
        break;
      }

      case "clear": {
        outputEl.innerHTML = "";
        break;
      }

      case "whoami": {
        appendOutput("kevin");
        break;
      }

      case "neofetch":
      case "fastfetch": {
        appendOutput(neofetchOutput());
        break;
      }

      default: {
        appendOutput(`${escapeHtml(cmd)}: command not found`);
        break;
      }
    }
  }

  function scrollToBottom() {
    terminalEl.scrollTop = terminalEl.scrollHeight;
  }

  function handleSubmit() {
    const value = inputEl.value;
    const promptHtml = renderPrompt();
    appendOutput(`${promptHtml}${escapeHtml(value)}`);

    if (value.trim()) {
      history.push(value);
    }
    historyIndex = history.length;

    inputEl.value = "";
    processCommand(value);
    scrollToBottom();
  }

  const commands = ["help", "ls", "cd", "cat", "open", "pwd", "clear", "whoami", "neofetch", "fastfetch"];

  let tabMatches: string[] = [];
  let tabIndex = -1;
  let tabPrefix = "";

  function tabComplete() {
    const value = inputEl.value;
    const parts = value.split(/\s+/);

    if (tabMatches.length > 0 && tabIndex >= 0) {
      tabIndex = (tabIndex + 1) % tabMatches.length;
      inputEl.value = tabMatches[tabIndex];
      return;
    }

    if (parts.length <= 1) {
      const prefix = parts[0];
      const matches = commands.filter((c) => c.startsWith(prefix)).sort();
      if (matches.length === 1) {
        inputEl.value = matches[0] + " ";
      } else if (matches.length > 1) {
        tabMatches = matches.map((m) => m + " ");
        tabIndex = 0;
        inputEl.value = tabMatches[0];
      }
      return;
    }

    const cmd = parts[0];
    if (!["cat", "cd", "ls", "open"].includes(cmd)) return;

    const arg = parts[parts.length - 1];
    const lastSlash = arg.lastIndexOf("/");
    const dirPart = lastSlash >= 0 ? arg.slice(0, lastSlash + 1) : "";
    const prefix = lastSlash >= 0 ? arg.slice(lastSlash + 1) : arg;

    const resolved = resolvePath(dirPart || cwd);
    const node = getNode(resolved);
    if (node == null || typeof node === "string") return;

    const entries = Object.keys(node).filter((e) => e.startsWith(prefix)).sort();
    const completions = entries.map((e) => {
      const isDir = typeof node[e] === "object";
      return dirPart + e + (isDir ? "/" : "");
    });

    if (completions.length === 1) {
      const match = completions[0];
      const isDir = match.endsWith("/");
      parts[parts.length - 1] = match;
      inputEl.value = parts.join(" ") + (isDir ? "" : " ");
    } else if (completions.length > 1) {
      tabMatches = completions.map((c) => {
        const before = parts.slice(0, -1).join(" ");
        return before + (before ? " " : "") + c;
      });
      tabIndex = 0;
      inputEl.value = tabMatches[0];
    }
  }

  function resetTabState() {
    tabMatches = [];
    tabIndex = -1;
  }

  let reverseSearchActive = false;
  let reverseSearchQuery = "";
  let reverseSearchIndex = -1;

  function updateReverseSearchPrompt() {
    const match = reverseSearchIndex >= 0 ? history[reverseSearchIndex] : "";
    promptEl.innerHTML = `(reverse-i-search)\`${escapeHtml(reverseSearchQuery)}': `;
    inputEl.value = match;
  }

  function exitReverseSearch(keepValue: boolean) {
    reverseSearchActive = false;
    const val = keepValue && reverseSearchIndex >= 0 ? history[reverseSearchIndex] : "";
    reverseSearchQuery = "";
    reverseSearchIndex = -1;
    updatePrompt();
    inputEl.value = val;
  }

  function searchHistory(query: string, startFrom: number): number {
    for (let i = startFrom; i >= 0; i--) {
      if (history[i].includes(query)) return i;
    }
    return -1;
  }

  inputEl.addEventListener("keydown", (e: KeyboardEvent) => {
    if (reverseSearchActive) {
      if (e.key === "Escape") {
        e.preventDefault();
        exitReverseSearch(false);
        return;
      }
      if (e.key === "Enter") {
        e.preventDefault();
        const val = reverseSearchIndex >= 0 ? history[reverseSearchIndex] : "";
        exitReverseSearch(false);
        inputEl.value = val;
        handleSubmit();
        return;
      }
      if (e.ctrlKey && e.key === "r") {
        e.preventDefault();
        const next = reverseSearchIndex > 0
          ? searchHistory(reverseSearchQuery, reverseSearchIndex - 1)
          : -1;
        if (next >= 0) reverseSearchIndex = next;
        updateReverseSearchPrompt();
        return;
      }
      if (e.ctrlKey && e.key === "c") {
        e.preventDefault();
        exitReverseSearch(false);
        return;
      }
      if (e.key === "Backspace") {
        e.preventDefault();
        reverseSearchQuery = reverseSearchQuery.slice(0, -1);
        reverseSearchIndex = searchHistory(reverseSearchQuery, history.length - 1);
        updateReverseSearchPrompt();
        return;
      }
      if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
        e.preventDefault();
        reverseSearchQuery += e.key;
        reverseSearchIndex = searchHistory(reverseSearchQuery, history.length - 1);
        updateReverseSearchPrompt();
        return;
      }
      exitReverseSearch(true);
      return;
    }

    if (e.key === "Tab") {
      e.preventDefault();
      tabComplete();
      return;
    }
    resetTabState();
    if (e.key === "Enter") {
      e.preventDefault();
      handleSubmit();
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      if (historyIndex > 0) {
        historyIndex--;
        inputEl.value = history[historyIndex];
      }
    } else if (e.key === "ArrowDown") {
      e.preventDefault();
      if (historyIndex < history.length - 1) {
        historyIndex++;
        inputEl.value = history[historyIndex];
      } else {
        historyIndex = history.length;
        inputEl.value = "";
      }
    } else if (e.ctrlKey && e.key === "l") {
      e.preventDefault();
      outputEl.innerHTML = "";
    } else if (e.ctrlKey && e.key === "r") {
      e.preventDefault();
      reverseSearchActive = true;
      reverseSearchQuery = "";
      reverseSearchIndex = -1;
      updateReverseSearchPrompt();
    } else if (e.ctrlKey && e.key === "c") {
      e.preventDefault();
      appendOutput(`${renderPrompt()}${escapeHtml(inputEl.value)}^C`);
      inputEl.value = "";
      scrollToBottom();
    } else if (e.ctrlKey && e.key === "u") {
      e.preventDefault();
      const pos = inputEl.selectionStart ?? 0;
      inputEl.value = inputEl.value.slice(pos);
      inputEl.selectionStart = inputEl.selectionEnd = 0;
    } else if (e.ctrlKey && e.key === "k") {
      e.preventDefault();
      const pos = inputEl.selectionStart ?? inputEl.value.length;
      inputEl.value = inputEl.value.slice(0, pos);
    } else if (e.ctrlKey && e.key === "w") {
      e.preventDefault();
      const pos = inputEl.selectionStart ?? inputEl.value.length;
      const before = inputEl.value.slice(0, pos);
      const after = inputEl.value.slice(pos);
      const trimmed = before.replace(/\S+\s*$/, "");
      inputEl.value = trimmed + after;
      inputEl.selectionStart = inputEl.selectionEnd = trimmed.length;
    } else if (e.ctrlKey && e.key === "a") {
      e.preventDefault();
      inputEl.selectionStart = inputEl.selectionEnd = 0;
    } else if (e.ctrlKey && e.key === "e") {
      e.preventDefault();
      inputEl.selectionStart = inputEl.selectionEnd = inputEl.value.length;
    }
  });

  terminalEl.addEventListener("click", () => {
    inputEl.focus();
  });

  updatePrompt();
  appendOutput(neofetchOutput());
  scrollToBottom();
  inputEl.focus();
</script>
</BaseLayout>
